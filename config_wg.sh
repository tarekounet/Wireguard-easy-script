#!/bin/bash

add_script_autostart_to_user() {
    TARGETUSER="$1"
    PROFILE="/home/$TARGETUSER/.bash_profile"
    SCRIPT_PATH="/home/$TARGETUSER/wireguard-script-manager/config_wg.sh"
    if ! grep -q "$SCRIPT_PATH" "$PROFILE" 2>/dev/null; then
        echo '[[ $- == *i* ]] && cd ~/wireguard-script-manager && bash ./config_wg.sh' >> "$PROFILE"
        chown "$TARGETUSER:$TARGETUSER" "$PROFILE"
    fi
}

##############################
#   VARIABLES G√âN√âRALES      #
##############################

GITHUB_USER="tarekounet"
GITHUB_REPO="Wireguard-easy-script"
BRANCH="main"
CONF_FILE="config/wg-easy.conf"
VERSION_FILE="version.txt"
CHANGELOG_FILE="CHANGELOG.md"
SCRIPT_VERSION="0.9.0"  # Version par d√©faut
SCRIPT_BACKUP="config_wg.sh.bak"
# D√©tection du bon HOME utilisateur m√™me en sudo/root
if [[ $EUID -eq 0 && -n "$SUDO_USER" ]]; then
    USER_HOME="$(getent passwd $SUDO_USER | cut -d: -f6)"
else
    USER_HOME="$HOME"
fi

# V√©rifier plusieurs emplacements possibles pour docker-wireguard
POSSIBLE_DOCKER_DIRS=(
    "$USER_HOME/docker-wireguard"
    "./docker-wireguard"
    "../docker-wireguard"
    "$USER_HOME/wireguard-script-manager/docker-wireguard"
    "docker-wireguard"
)

DOCKER_WG_DIR=""
DOCKER_COMPOSE_FILE=""

# Trouver le bon r√©pertoire docker-wireguard
for dir in "${POSSIBLE_DOCKER_DIRS[@]}"; do
    if [[ -d "$dir" && -f "$dir/docker-compose.yml" ]]; then
        DOCKER_WG_DIR="$dir"
        DOCKER_COMPOSE_FILE="$DOCKER_WG_DIR/docker-compose.yml"
        echo "‚úì R√©pertoire docker-wireguard trouv√© : $DOCKER_WG_DIR"
        break
    fi
done

# Si aucun r√©pertoire trouv√©, utiliser le chemin par d√©faut
if [[ -z "$DOCKER_WG_DIR" ]]; then
    DOCKER_WG_DIR="$USER_HOME/docker-wireguard"
    DOCKER_COMPOSE_FILE="$DOCKER_WG_DIR/docker-compose.yml"
    echo "‚úó Aucun r√©pertoire docker-wireguard trouv√©, utilisation du chemin par d√©faut : $DOCKER_WG_DIR"
fi

WG_CONF_DIR="$DOCKER_WG_DIR/config"
SCRIPT_BASE_VERSION_INIT="0.9.0"

export GITHUB_USER
export GITHUB_REPO
export BRANCH

# Fonction pour r√©cup√©rer ou cr√©er le fichier version.txt
get_or_create_version() {
    if [[ ! -f "$VERSION_FILE" ]]; then
        echo "üì• Fichier version.txt manquant, r√©cup√©ration depuis GitHub..."
        if REMOTE_VERSION=$(curl -fsSL --connect-timeout 5 "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/version.txt" 2>/dev/null | head -n1 | tr -d '\n\r '); then
            if [[ -n "$REMOTE_VERSION" ]]; then
                echo "$REMOTE_VERSION" > "$VERSION_FILE"
                echo "‚úì Fichier version.txt cr√©√© avec la version : $REMOTE_VERSION"
                echo "$REMOTE_VERSION"
                return
            fi
        fi
        # Si √©chec, cr√©er avec la version par d√©faut
        echo "$SCRIPT_BASE_VERSION_INIT" > "$VERSION_FILE"
        echo "‚úó Impossible de r√©cup√©rer la version depuis GitHub, utilisation de la version par d√©faut : $SCRIPT_BASE_VERSION_INIT"
        echo "$SCRIPT_BASE_VERSION_INIT"
    else
        VERSION_FROM_FILE=$(cat "$VERSION_FILE" 2>/dev/null | head -n1 | tr -d '\n\r ')
        if [[ -n "$VERSION_FROM_FILE" ]]; then
            echo "$VERSION_FROM_FILE"
        else
            echo "$SCRIPT_BASE_VERSION_INIT" > "$VERSION_FILE"
            echo "$SCRIPT_BASE_VERSION_INIT"
        fi
    fi
}

# Fonction pour r√©cup√©rer le fichier CHANGELOG.md
get_or_create_changelog() {
    if [[ ! -f "$CHANGELOG_FILE" ]]; then
        echo "üì• Fichier CHANGELOG.md manquant, r√©cup√©ration depuis GitHub..."
        if curl -fsSL --connect-timeout 10 "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/CHANGELOG.md" -o "$CHANGELOG_FILE" 2>/dev/null; then
            if [[ -f "$CHANGELOG_FILE" && -s "$CHANGELOG_FILE" ]]; then
                echo "‚úì Fichier CHANGELOG.md r√©cup√©r√© avec succ√®s depuis GitHub"
                return 0
            fi
        fi
        # Si √©chec, ne pas cr√©er de fichier
        echo "‚úó Changelog non disponible (impossible de r√©cup√©rer depuis GitHub)"
        return 1
    else
        echo "‚úì Fichier CHANGELOG.md d√©j√† pr√©sent"
        return 0
    fi
}

# D√©tection de la version du script
SCRIPT_VERSION=$(get_or_create_version)
SCRIPT_BASE_VERSION_INIT="$SCRIPT_VERSION"

# R√©cup√©ration ou cr√©ation du changelog
get_or_create_changelog

echo "Version du script : $SCRIPT_VERSION"

##############################
#   MISE √Ä JOUR AUTOMATIQUE  #
##############################

# Fonction de comparaison de versions (format: X.Y.Z)
compare_versions() {
    local version1="$1"
    local version2="$2"
    
    # Normaliser les versions (enlever les pr√©fixes 'v' √©ventuels)
    version1="${version1#v}"
    version2="${version2#v}"
    
    # Comparer les versions
    printf '%s\n%s' "$version1" "$version2" | sort -V | head -n1
}

# Fonction de mise √† jour automatique
auto_update_on_startup() {
    echo "üîÑ V√©rification des mises √† jour..."
    
    # V√©rifier la version du script sur GitHub
    LATEST_SCRIPT_VERSION=$(curl -fsSL --connect-timeout 5 "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/version.txt" 2>/dev/null | head -n1 | tr -d '\n\r ')
    
    if [[ -n "$LATEST_SCRIPT_VERSION" ]]; then
        # Comparer les versions - ne mettre √† jour que si la version distante est plus r√©cente
        if [[ "$LATEST_SCRIPT_VERSION" != "$SCRIPT_VERSION" ]]; then
            OLDEST_VERSION=$(compare_versions "$SCRIPT_VERSION" "$LATEST_SCRIPT_VERSION")
            if [[ "$OLDEST_VERSION" == "$SCRIPT_VERSION" ]]; then
                echo "üÜï Nouvelle version du script disponible : $LATEST_SCRIPT_VERSION (actuelle : $SCRIPT_VERSION)"
                echo "üì• Mise √† jour automatique en cours..."
                
                # Sauvegarder le script actuel
                cp "$0" "${0}.backup.$(date +%Y%m%d_%H%M%S)" 2>/dev/null
                
                # T√©l√©charger la nouvelle version
                if curl -fsSL -o "$0.tmp" "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/config_wg.sh"; then
                    chmod +x "$0.tmp"
                    mv "$0.tmp" "$0"
                    
                    # Mettre √† jour le fichier version.txt
                    echo "$LATEST_SCRIPT_VERSION" > "$VERSION_FILE"
                    
                    # Mettre √† jour le changelog
                    echo "üì• Mise √† jour du changelog..."
                    if curl -fsSL --connect-timeout 10 "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/CHANGELOG.md" -o "$CHANGELOG_FILE.tmp" 2>/dev/null; then
                        if [[ -f "$CHANGELOG_FILE.tmp" && -s "$CHANGELOG_FILE.tmp" ]]; then
                            mv "$CHANGELOG_FILE.tmp" "$CHANGELOG_FILE"
                            echo "‚úÖ Changelog mis √† jour"
                        else
                            rm -f "$CHANGELOG_FILE.tmp" 2>/dev/null
                            echo "‚ö†Ô∏è  Changelog inchang√© (fichier vide ou invalide)"
                        fi
                    else
                        echo "‚ö†Ô∏è  Impossible de mettre √† jour le changelog"
                    fi
                    
                    # Mettre √† jour les modules aussi
                    echo "üîÑ Mise √† jour des modules suite √† la nouvelle version..."
                    update_modules_from_github
                    
                    echo "‚úÖ Script mis √† jour vers la version $LATEST_SCRIPT_VERSION"
                    echo "üîÑ Red√©marrage du script avec la nouvelle version..."
                    
                    # Relancer le script avec la nouvelle version
                    exec bash "$0" "$@"
                else
                    echo "‚ùå √âchec de la mise √† jour du script"
                    rm -f "$0.tmp" 2>/dev/null
                fi
            else
                echo "‚úÖ Script √† jour (version locale $SCRIPT_VERSION >= version distante $LATEST_SCRIPT_VERSION)"
            fi
        else
            echo "‚úÖ Script √† jour (version $SCRIPT_VERSION)"
        fi
    else
        echo "‚ö†Ô∏è  Impossible de v√©rifier la version distante"
        echo "‚úÖ Script version locale : $SCRIPT_VERSION"
    fi
}

# Ex√©cuter la mise √† jour automatique seulement si le script est lanc√© directement
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    auto_update_on_startup "$@"
fi

# Fonction pour mettre √† jour les modules depuis GitHub
update_modules_from_github() {
    echo "üîÑ Mise √† jour des modules depuis GitHub..."
    for mod in utils conf docker menu ; do
        echo "Mise √† jour de lib/$mod.sh depuis GitHub ($BRANCH)..."
        if curl -fsSL -o "lib/$mod.sh" "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/lib/$mod.sh"; then
            chmod +x "lib/$mod.sh"
            echo "‚úÖ Module lib/$mod.sh mis √† jour avec succ√®s"
        else
            echo "‚ùå √âchec de la mise √† jour de lib/$mod.sh"
            if [[ ! -f "lib/$mod.sh" ]]; then
                echo "‚ùå Module manquant et impossible √† t√©l√©charger"
                exit 1
            else
                echo "‚ö†Ô∏è  Utilisation de la version locale existante"
            fi
        fi
        # Pause de 1 seconde entre chaque t√©l√©chargement
        sleep 1
    done
}

# Fonction pour mettre √† jour le changelog ind√©pendamment
update_changelog_from_github() {
    echo "üîÑ V√©rification du changelog sur GitHub..."
    
    if curl -fsSL --connect-timeout 10 "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/CHANGELOG.md" -o "$CHANGELOG_FILE.tmp" 2>/dev/null; then
        if [[ -f "$CHANGELOG_FILE.tmp" && -s "$CHANGELOG_FILE.tmp" ]]; then
            # Comparer les contenus si le fichier local existe
            if [[ -f "$CHANGELOG_FILE" ]]; then
                if ! cmp -s "$CHANGELOG_FILE" "$CHANGELOG_FILE.tmp"; then
                    # Cr√©er une sauvegarde avant de remplacer
                    cp "$CHANGELOG_FILE" "$CHANGELOG_FILE.backup.$(date +%Y%m%d_%H%M%S)" 2>/dev/null
                    mv "$CHANGELOG_FILE.tmp" "$CHANGELOG_FILE"
                    echo "‚úÖ Changelog mis √† jour depuis GitHub"
                    return 0
                else
                    rm -f "$CHANGELOG_FILE.tmp"
                    echo "‚úÖ Changelog d√©j√† √† jour"
                    return 0
                fi
            else
                mv "$CHANGELOG_FILE.tmp" "$CHANGELOG_FILE"
                echo "‚úÖ Changelog r√©cup√©r√© depuis GitHub"
                return 0
            fi
        else
            rm -f "$CHANGELOG_FILE.tmp" 2>/dev/null
            echo "‚ö†Ô∏è  Fichier changelog distant vide ou invalide"
            return 1
        fi
    else
        echo "‚ùå Impossible de r√©cup√©rer le changelog depuis GitHub"
        return 1
    fi
}

##############################
#   AUTO-BOOTSTRAP MODULES   #
##############################

# Cr√©ation des dossiers n√©cessaires
for dir in lib config; do
    if [[ ! -d "$dir" ]]; then
        mkdir -p "$dir"
        echo "Dossier cr√©√© : $dir/"
    fi
    if [[ ! -w "$dir" || ! -r "$dir" ]]; then
        echo "Erreur : le dossier '$dir/' n'est pas accessible en lecture/√©criture."
        exit 1
    fi
done

# V√©rifier si les modules existent, sinon les t√©l√©charger une premi√®re fois
MODULES_MISSING=false
for mod in utils conf docker menu ; do
    if [[ ! -f "lib/$mod.sh" ]]; then
        echo "‚ö†Ô∏è  Module lib/$mod.sh manquant"
        MODULES_MISSING=true
    fi
done

# Si des modules manquent, les t√©l√©charger
if [[ "$MODULES_MISSING" == "true" ]]; then
    echo "üì• T√©l√©chargement des modules manquants..."
    update_modules_from_github
fi

# Chargement des modules
echo "Chargement des modules..."
for f in lib/*.sh; do
    if [[ -f "$f" ]]; then
        echo "Chargement de $f"
        source "$f"
    else
        echo "Erreur : Module $f introuvable apr√®s t√©l√©chargement"
        exit 1
    fi
    # Pause de 1 seconde entre chaque chargement de module
    sleep 1
done
echo "‚úì Tous les modules sont charg√©s"

##############################
#   INITIALISATION DE LA CONF
##############################

# 1. R√©cup√©ration depuis GitHub
WG_EASY_VERSION_URL="https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/WG_EASY_VERSION"
echo "R√©cup√©ration de la version WG-Easy depuis GitHub..."

# Essayer de r√©cup√©rer la version depuis GitHub
WG_EASY_VERSION=$(curl -fsSL --connect-timeout 10 "$WG_EASY_VERSION_URL" 2>/dev/null | head -n1 | tr -d '\n\r')

# Si √©chec, utiliser une version par d√©faut
if [[ -z "$WG_EASY_VERSION" ]]; then
    WG_EASY_VERSION="15.1.0"  # Version par d√©faut r√©cente
    echo "‚úó Impossible de r√©cup√©rer la version depuis GitHub, utilisation de la version par d√©faut : $WG_EASY_VERSION"
else
    echo "‚úì Version r√©cup√©r√©e depuis GitHub : $WG_EASY_VERSION"
fi

# V√©rification explicite de la version locale
WG_EASY_VERSION_LOCAL_FILE="WG_EASY_VERSION"
WG_EASY_VERSION_LOCAL=""

# D'abord, essayer de lire le fichier WG_EASY_VERSION local (dans le r√©pertoire du script)
echo "Lecture du fichier WG_EASY_VERSION local..."
if [[ -f "$WG_EASY_VERSION_LOCAL_FILE" && -s "$WG_EASY_VERSION_LOCAL_FILE" ]]; then
    WG_EASY_VERSION_LOCAL=$(cat "$WG_EASY_VERSION_LOCAL_FILE" 2>/dev/null | head -n1 | tr -d '\n\r ')
    if [[ -n "$WG_EASY_VERSION_LOCAL" && "$WG_EASY_VERSION_LOCAL" != "" ]]; then
        echo "‚úì Version locale trouv√©e dans WG_EASY_VERSION : $WG_EASY_VERSION_LOCAL"
    else
        echo "‚úó Fichier WG_EASY_VERSION vide"
        WG_EASY_VERSION_LOCAL=""
    fi
else
    echo "‚úó Fichier WG_EASY_VERSION non trouv√© ou vide"
fi

# Si pas de version locale trouv√©e, cr√©er le fichier avec la version GitHub
if [[ -z "$WG_EASY_VERSION_LOCAL" ]]; then
    echo "$WG_EASY_VERSION" > "$WG_EASY_VERSION_LOCAL_FILE"
    WG_EASY_VERSION_LOCAL="$WG_EASY_VERSION"
    echo "‚úì Fichier WG_EASY_VERSION cr√©√© avec la version $WG_EASY_VERSION"
fi

# Si docker-compose.yml existe, extraire la version actuelle
echo "V√©rification du fichier docker-compose.yml..."
echo "Chemin recherch√© : $DOCKER_COMPOSE_FILE"

if [[ -f "$DOCKER_COMPOSE_FILE" ]]; then
    echo "‚úì Fichier docker-compose.yml trouv√© dans $DOCKER_WG_DIR"
    CURRENT_VERSION_IN_COMPOSE=$(grep -o 'ghcr.io/wg-easy/wg-easy:[^[:space:]]*' "$DOCKER_COMPOSE_FILE" 2>/dev/null | cut -d: -f3 | head -n1)
    if [[ -n "$CURRENT_VERSION_IN_COMPOSE" ]]; then
        echo "Version actuelle dans docker-compose.yml : $CURRENT_VERSION_IN_COMPOSE"
        # Utiliser la version du docker-compose comme r√©f√©rence locale (priorit√© sur le fichier WG_EASY_VERSION)
        WG_EASY_VERSION_LOCAL="$CURRENT_VERSION_IN_COMPOSE"
    else
        echo "‚úó Impossible d'extraire la version depuis docker-compose.yml"
        echo "‚Üí Utilisation de la version du fichier WG_EASY_VERSION : $WG_EASY_VERSION_LOCAL"
    fi
else
    echo "‚úó Fichier docker-compose.yml non trouv√©"
    echo "‚Üí Utilisation de la version du fichier WG_EASY_VERSION : $WG_EASY_VERSION_LOCAL"
    echo "‚úó Emplacements v√©rifi√©s :"
    for dir in "${POSSIBLE_DOCKER_DIRS[@]}"; do
        echo "   - $dir/docker-compose.yml"
    done
fi

# V√©rification et comparaison apr√®s d√©tection du fichier local
echo "=== DIAGNOSTIC COMPLET ==="
echo "R√©pertoire de travail : $(pwd)"
echo "R√©pertoire docker-wireguard : $DOCKER_WG_DIR"
echo "Fichier version.txt : $VERSION_FILE (existe: $(test -f "$VERSION_FILE" && echo "OUI" || echo "NON"))"
echo "Fichier WG_EASY_VERSION : $WG_EASY_VERSION_LOCAL_FILE (existe: $(test -f "$WG_EASY_VERSION_LOCAL_FILE" && echo "OUI" || echo "NON"))"
echo "Fichier docker-compose : $DOCKER_COMPOSE_FILE (existe: $(test -f "$DOCKER_COMPOSE_FILE" && echo "OUI" || echo "NON"))"
echo "=========================="

echo "=== R√âSUM√â DES VERSIONS ==="
echo "Version GitHub : ${WG_EASY_VERSION:-VIDE}"
echo "Version locale : ${WG_EASY_VERSION_LOCAL:-VIDE}"
echo "Version script : ${SCRIPT_VERSION:-VIDE}"
echo "=========================="

if [[ "$WG_EASY_VERSION_LOCAL" != "$WG_EASY_VERSION" && "$WG_EASY_VERSION" != "inconnu" && -n "$WG_EASY_VERSION_LOCAL" && "$WG_EASY_VERSION_LOCAL" != "inconnu" ]]; then
    echo -e "üÜï Nouvelle version Wireguard Easy disponible : $WG_EASY_VERSION (actuelle : $WG_EASY_VERSION_LOCAL)"
    echo -e "üì• Mise √† jour automatique du docker-compose.yml..."
    
    if [[ -f "$DOCKER_COMPOSE_FILE" ]]; then
        # Sauvegarder le fichier avant modification
        cp "$DOCKER_COMPOSE_FILE" "$DOCKER_COMPOSE_FILE.bak.$(date +%Y%m%d_%H%M%S)"
        sed -i "s|image: ghcr.io/wg-easy/wg-easy:.*|image: ghcr.io/wg-easy/wg-easy:$WG_EASY_VERSION|" "$DOCKER_COMPOSE_FILE"
        # Mettre √† jour le fichier de version locale
        echo "$WG_EASY_VERSION" > "$WG_EASY_VERSION_LOCAL_FILE"
        echo -e "‚úÖ Docker-compose.yml mis √† jour automatiquement vers la version $WG_EASY_VERSION"
        echo -e "üíæ Sauvegarde cr√©√©e avec horodatage"
    else
        echo -e "‚ùå Le fichier docker-compose.yml est introuvable dans $DOCKER_COMPOSE_FILE"
    fi
elif [[ "$WG_EASY_VERSION_LOCAL" == "$WG_EASY_VERSION" ]]; then
    echo -e "‚úÖ Votre version Wireguard Easy est √† jour : $WG_EASY_VERSION"
elif [[ -z "$WG_EASY_VERSION_LOCAL" || "$WG_EASY_VERSION_LOCAL" == "inconnu" ]]; then
    echo -e "‚ö†Ô∏è  Impossible de d√©terminer la version actuelle. Fichier docker-compose.yml introuvable."
    echo -e "üìù Assurez-vous que Wireguard Easy est install√© et que le fichier docker-compose.yml existe."
fi

# 2. Cr√©ation du fichier de conf (si besoin)
if [[ ! -f "$CONF_FILE" ]]; then
    msg_warn "Le fichier de configuration n'existe pas. Cr√©ation en cours..."
    set_tech_password
    EXPECTED_HASH="$(get_conf_value "EXPECTED_HASH")"
    HASH_SALT="$(get_conf_value "HASH_SALT")"
    cat > "$CONF_FILE" <<EOF
EXPECTED_HASH="$EXPECTED_HASH"
HASH_SALT="$HASH_SALT"
WG_EASY_VERSION="$WG_EASY_VERSION"
EOF
    msg_success "Fichier de configuration cr√©√© avec succ√®s."
fi

# 3. Mise √† jour de la version dans la conf √† chaque lancement
set_conf_value "WG_EASY_VERSION" "$WG_EASY_VERSION"

# V√©rification du mot de passe technique uniquement si le hash est encore vide
EXPECTED_HASH=$(get_conf_value "EXPECTED_HASH")
if [[ -z "$EXPECTED_HASH" ]]; then
    msg_warn "Aucun mot de passe technique enregistr√©. Veuillez en d√©finir un."
    set_tech_password
fi

##############################
#   LANCEMENT DU SCRIPT      #
##############################

# Lancement du menu principal uniquement si le script est ex√©cut√© directement
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    main_menu
fi