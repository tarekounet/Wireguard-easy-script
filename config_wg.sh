#!/bin/bash

##############################
#   VARIABLES G√âN√âRALES      #
##############################

GITHUB_USER="tarekounet"
GITHUB_REPO="Wireguard-easy-script"
BRANCH="main"
VERSION_FILE="version.txt"
CHANGELOG_FILE="CHANGELOG.md"
# Utilisation du HOME de l'utilisateur actuel
USER_HOME="$HOME"

# V√©rifier plusieurs emplacements possibles pour docker-wireguard
POSSIBLE_DOCKER_DIRS=(
    "$USER_HOME/docker-wireguard"
    "./docker-wireguard"
    "../docker-wireguard"
    "$USER_HOME/wireguard-script-manager/docker-wireguard"
    "docker-wireguard"
)

DOCKER_WG_DIR=""
DOCKER_COMPOSE_FILE=""

# Trouver le bon r√©pertoire docker-wireguard
for dir in "${POSSIBLE_DOCKER_DIRS[@]}"; do
    if [[ -d "$dir" && -f "$dir/docker-compose.yml" ]]; then
        DOCKER_WG_DIR="$dir"
        DOCKER_COMPOSE_FILE="$DOCKER_WG_DIR/docker-compose.yml"
        echo "‚úì R√©pertoire docker-wireguard trouv√© : $DOCKER_WG_DIR"
        break
    fi
done

# Si aucun r√©pertoire trouv√©, utiliser le chemin par d√©faut
if [[ -z "$DOCKER_WG_DIR" ]]; then
    DOCKER_WG_DIR="$USER_HOME/docker-wireguard"
    DOCKER_COMPOSE_FILE="$DOCKER_WG_DIR/docker-compose.yml"
    echo "‚úó Aucun r√©pertoire docker-wireguard trouv√©, utilisation du chemin par d√©faut : $DOCKER_WG_DIR"
fi

WG_CONF_DIR="$DOCKER_WG_DIR/config"

export GITHUB_USER
export GITHUB_REPO
export BRANCH

# Version par d√©faut pour fallback
readonly DEFAULT_VERSION="0.28.2"

##############################
#   FONCTIONS UTILITAIRES    #
##############################

# Fonction pour mettre √† jour les modules depuis GitHub
update_modules_from_github() {
    echo "üîÑ Mise √† jour des modules depuis GitHub..."
    for mod in utils docker menu ; do
        echo "Mise √† jour de lib/$mod.sh depuis GitHub ($BRANCH)..."
        if curl -fsSL --connect-timeout 10 --max-time 20 -o "lib/$mod.sh" "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/lib/$mod.sh" 2>/dev/null; then
            chmod +x "lib/$mod.sh"
            echo "‚úÖ Module lib/$mod.sh mis √† jour avec succ√®s"
        else
            echo "‚ö†Ô∏è  √âchec de la mise √† jour de lib/$mod.sh"
            if [[ ! -f "lib/$mod.sh" ]]; then
                echo "‚ùå Module manquant et impossible √† t√©l√©charger - Arr√™t du script"
                echo "üí° V√©rifiez votre connexion r√©seau et r√©essayez"
                exit 1
            else
                echo "üì± Utilisation de la version locale existante de lib/$mod.sh"
            fi
        fi
    done
}

# Fonction pour r√©cup√©rer ou cr√©er le fichier version.txt
get_or_create_version() {
    if [[ ! -f "$VERSION_FILE" ]]; then
        echo "üì• Fichier version.txt manquant, r√©cup√©ration depuis GitHub..."
        
        # Try with curl first
        REMOTE_VERSION=""
        if command -v curl >/dev/null 2>&1; then
            REMOTE_VERSION=$(curl -fsSL --connect-timeout 3 --max-time 10 "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/version.txt" 2>/dev/null | head -n1 | tr -d '\n\r ' || echo "")
        fi
        
        # Fallback with wget
        if [[ -z "$REMOTE_VERSION" ]] && command -v wget >/dev/null 2>&1; then
            REMOTE_VERSION=$(wget -qO- --timeout=5 --tries=1 "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/version.txt" 2>/dev/null | head -n1 | tr -d '\n\r ' || echo "")
        fi
        
        if [[ -n "$REMOTE_VERSION" ]]; then
            echo "$REMOTE_VERSION" > "$VERSION_FILE"
            echo "‚úì Fichier version.txt cr√©√© avec la version : $REMOTE_VERSION"
            echo "$REMOTE_VERSION"
            return
        fi
        
        # Si √©chec, cr√©er avec la version par d√©faut
        echo "$DEFAULT_VERSION" > "$VERSION_FILE"
        echo "‚ö†Ô∏è  Impossible de r√©cup√©rer la version depuis GitHub, utilisation de la version par d√©faut : $DEFAULT_VERSION"
        echo "$DEFAULT_VERSION"
    else
        VERSION_FROM_FILE=$(cat "$VERSION_FILE" 2>/dev/null | head -n1 | tr -d '\n\r ')
        if [[ -n "$VERSION_FROM_FILE" ]]; then
            echo "$VERSION_FROM_FILE"
        else
            echo "$DEFAULT_VERSION" > "$VERSION_FILE"
            echo "‚ö†Ô∏è  Fichier version.txt vide, recr√©ation avec version par d√©faut : $DEFAULT_VERSION"
            echo "$DEFAULT_VERSION"
        fi
    fi
}

# Fonction pour r√©cup√©rer le fichier CHANGELOG.md
get_or_create_changelog() {
    if [[ ! -f "$CHANGELOG_FILE" ]]; then
        echo "üì• Fichier CHANGELOG.md manquant, r√©cup√©ration depuis GitHub..."
        if curl -fsSL --connect-timeout 10 --max-time 20 "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/CHANGELOG.md" -o "$CHANGELOG_FILE" 2>/dev/null; then
            if [[ -f "$CHANGELOG_FILE" && -s "$CHANGELOG_FILE" ]]; then
                echo "‚úì Fichier CHANGELOG.md r√©cup√©r√© avec succ√®s depuis GitHub"
                return 0
            fi
        fi
        # Si √©chec, ne pas cr√©er de fichier
        echo "‚ö†Ô∏è  Changelog non disponible (impossible de r√©cup√©rer depuis GitHub)"
        return 1
    else
        echo "‚úì Fichier CHANGELOG.md d√©j√† pr√©sent"
        return 0
    fi
}

# D√©tection de la version du script
SCRIPT_VERSION=$(get_or_create_version)

# R√©cup√©ration ou cr√©ation du changelog
get_or_create_changelog

echo "Version du script : $SCRIPT_VERSION"

##############################
#   MISE √Ä JOUR AUTOMATIQUE  #
##############################

# Fonction de comparaison de versions (format: X.Y.Z)
compare_versions() {
    local version1="$1"
    local version2="$2"
    
    # Normaliser les versions (enlever les pr√©fixes 'v' √©ventuels)
    version1="${version1#v}"
    version2="${version2#v}"
    
    # Comparer les versions
    printf '%s\n%s' "$version1" "$version2" | sort -V | head -n1
}

# Fonction de mise √† jour automatique
auto_update_on_startup() {
    echo "üîÑ V√©rification des mises √† jour..."
    
    # V√©rifier la version du script sur GitHub avec gestion d'erreur robuste
    LATEST_SCRIPT_VERSION=""
    
    # First attempt: Primary URL with short timeout
    if command -v curl >/dev/null 2>&1; then
        LATEST_SCRIPT_VERSION=$(curl -fsSL --connect-timeout 3 --max-time 10 "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/version.txt" 2>/dev/null | head -n1 | tr -d '\n\r ' || echo "")
    fi
    
    # Fallback: Try with wget if curl failed
    if [[ -z "$LATEST_SCRIPT_VERSION" ]] && command -v wget >/dev/null 2>&1; then
        LATEST_SCRIPT_VERSION=$(wget -qO- --timeout=5 --tries=1 "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/version.txt" 2>/dev/null | head -n1 | tr -d '\n\r ' || echo "")
    fi
    
    if [[ -n "$LATEST_SCRIPT_VERSION" ]]; then
        # Comparer les versions - ne mettre √† jour que si la version distante est plus r√©cente
        if [[ "$LATEST_SCRIPT_VERSION" != "$SCRIPT_VERSION" ]]; then
            OLDEST_VERSION=$(compare_versions "$SCRIPT_VERSION" "$LATEST_SCRIPT_VERSION")
            if [[ "$OLDEST_VERSION" == "$SCRIPT_VERSION" ]]; then
                echo "üÜï Nouvelle version du script disponible : $LATEST_SCRIPT_VERSION (actuelle : $SCRIPT_VERSION)"
                echo "üì• Mise √† jour automatique en cours..."
                
                # Sauvegarder le script actuel
                cp "$0" "${0}.backup.$(date +%Y%m%d_%H%M%S)" 2>/dev/null
                
                # T√©l√©charger la nouvelle version
                if curl -fsSL --connect-timeout 10 --max-time 30 -o "$0.tmp" "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/config_wg.sh" 2>/dev/null; then
                    chmod +x "$0.tmp"
                    mv "$0.tmp" "$0"
                    
                    # Mettre √† jour le fichier version.txt
                    echo "$LATEST_SCRIPT_VERSION" > "$VERSION_FILE"
                    
                    # Mettre √† jour le changelog
                    echo "üì• Mise √† jour du changelog..."
                    if curl -fsSL --connect-timeout 10 --max-time 20 "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/CHANGELOG.md" -o "$CHANGELOG_FILE.tmp" 2>/dev/null; then
                        if [[ -f "$CHANGELOG_FILE.tmp" && -s "$CHANGELOG_FILE.tmp" ]]; then
                            mv "$CHANGELOG_FILE.tmp" "$CHANGELOG_FILE"
                            echo "‚úÖ Changelog mis √† jour"
                        else
                            rm -f "$CHANGELOG_FILE.tmp" 2>/dev/null
                            echo "‚ö†Ô∏è  Changelog inchang√© (fichier vide ou invalide)"
                        fi
                    else
                        echo "‚ö†Ô∏è  Impossible de mettre √† jour le changelog"
                    fi
                    
                    # Mettre √† jour les modules aussi
                    echo "üîÑ Mise √† jour des modules suite √† la nouvelle version..."
                    update_modules_from_github
                    
                    echo "‚úÖ Script mis √† jour vers la version $LATEST_SCRIPT_VERSION"
                    echo "üîÑ Red√©marrage du script avec la nouvelle version..."
                    
                    # Relancer le script avec la nouvelle version
                    exec bash "$0" "$@"
                else
                    echo "‚ö†Ô∏è  √âchec du t√©l√©chargement de la mise √† jour - Continuons avec la version actuelle"
                    rm -f "$0.tmp" 2>/dev/null
                    echo "üì± Poursuite avec la version locale : $SCRIPT_VERSION"
                fi
            else
                echo "‚úÖ Script √† jour (version locale $SCRIPT_VERSION >= version distante $LATEST_SCRIPT_VERSION)"
            fi
        else
            echo "‚úÖ Script √† jour (version $SCRIPT_VERSION)"
        fi
    else
        echo "‚ö†Ô∏è  Impossible de v√©rifier la version en ligne - Connexion r√©seau ou serveur indisponible"
        echo "üì± Continuons avec la version locale : $SCRIPT_VERSION"
    fi
}

# Ex√©cuter la mise √† jour automatique seulement si le script est lanc√© directement
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    auto_update_on_startup "$@"
fi

##############################
#   AUTO-BOOTSTRAP MODULES   #
##############################

# Cr√©ation des dossiers n√©cessaires
for dir in lib; do
    if [[ ! -d "$dir" ]]; then
        mkdir -p "$dir"
        echo "Dossier cr√©√© : $dir/"
    fi
    if [[ ! -w "$dir" || ! -r "$dir" ]]; then
        echo "Erreur : le dossier '$dir/' n'est pas accessible en lecture/√©criture."
        exit 1
    fi
done

# V√©rifier si les modules existent, sinon les t√©l√©charger une premi√®re fois
MODULES_MISSING=false
for mod in utils docker menu ; do
    if [[ ! -f "lib/$mod.sh" ]]; then
        echo "‚ö†Ô∏è  Module lib/$mod.sh manquant"
        MODULES_MISSING=true
    fi
done

# Si des modules manquent, les t√©l√©charger
if [[ "$MODULES_MISSING" == "true" ]]; then
    echo "üì• T√©l√©chargement des modules manquants..."
    update_modules_from_github
fi

# Chargement des modules
echo "Chargement des modules..."
for f in lib/*.sh; do
    if [[ -f "$f" ]]; then
        echo "Chargement de $f"
        source "$f"
    else
        echo "Erreur : Module $f introuvable apr√®s t√©l√©chargement"
        exit 1
    fi
done
echo "‚úì Tous les modules sont charg√©s"

##############################
#   INITIALISATION DE LA CONF
##############################

# D√©termination de la version WG-Easy (logique simplifi√©e)
WG_EASY_VERSION_DEFAULT="15.1.0"
WG_EASY_VERSION=""

echo "üîç D√©termination de la version WG-Easy..."

# 1. Si docker-compose.yml existe, utiliser sa version (PRIORIT√â)
if [[ -f "$DOCKER_COMPOSE_FILE" ]]; then
    WG_EASY_VERSION=$(grep -o 'ghcr.io/wg-easy/wg-easy:[^[:space:]]*' "$DOCKER_COMPOSE_FILE" 2>/dev/null | cut -d: -f3 | head -n1)
    if [[ -n "$WG_EASY_VERSION" ]]; then
        echo "‚úì Version depuis docker-compose.yml : $WG_EASY_VERSION"
    fi
fi

# 2. Si pas de version docker-compose, utiliser le fichier local WG_EASY_VERSION
if [[ -z "$WG_EASY_VERSION" && -f "WG_EASY_VERSION" ]]; then
    WG_EASY_VERSION=$(cat "WG_EASY_VERSION" 2>/dev/null | head -n1 | tr -d '\n\r ')
    if [[ -n "$WG_EASY_VERSION" ]]; then
        echo "‚úì Version depuis fichier local WG_EASY_VERSION : $WG_EASY_VERSION"
    fi
fi

# 3. Si toujours vide, r√©cup√©rer depuis GitHub
if [[ -z "$WG_EASY_VERSION" ]]; then
    WG_EASY_VERSION=$(curl -fsSL --connect-timeout 5 "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/WG_EASY_VERSION" 2>/dev/null | head -n1 | tr -d '\n\r')
    if [[ -n "$WG_EASY_VERSION" ]]; then
        echo "‚úì Version depuis GitHub : $WG_EASY_VERSION"
        # Sauvegarder dans fichier local
        echo "$WG_EASY_VERSION" > "WG_EASY_VERSION"
    fi
fi

# 4. Fallback sur version par d√©faut
if [[ -z "$WG_EASY_VERSION" ]]; then
    WG_EASY_VERSION="$WG_EASY_VERSION_DEFAULT"
    echo "‚úó Utilisation version par d√©faut : $WG_EASY_VERSION"
    echo "$WG_EASY_VERSION" > "WG_EASY_VERSION"
fi

# V√©rification des mises √† jour WG-Easy disponibles
echo "ÔøΩ V√©rification des mises √† jour WG-Easy..."
WG_EASY_LATEST=$(curl -fsSL --connect-timeout 5 "https://raw.githubusercontent.com/$GITHUB_USER/$GITHUB_REPO/$BRANCH/WG_EASY_VERSION" 2>/dev/null | head -n1 | tr -d '\n\r')

if [[ -n "$WG_EASY_LATEST" && "$WG_EASY_LATEST" != "$WG_EASY_VERSION" ]]; then
    echo "üÜï Nouvelle version WG-Easy disponible : $WG_EASY_LATEST (actuelle : $WG_EASY_VERSION)"
    if [[ -f "$DOCKER_COMPOSE_FILE" ]]; then
        echo "üì• Mise √† jour automatique du docker-compose.yml..."
        cp "$DOCKER_COMPOSE_FILE" "$DOCKER_COMPOSE_FILE.bak.$(date +%Y%m%d_%H%M%S)"
        sed -i "s|image: ghcr.io/wg-easy/wg-easy:.*|image: ghcr.io/wg-easy/wg-easy:$WG_EASY_LATEST|" "$DOCKER_COMPOSE_FILE"
        echo "$WG_EASY_LATEST" > "WG_EASY_VERSION"
        WG_EASY_VERSION="$WG_EASY_LATEST"
        echo "‚úÖ Mis √† jour vers la version $WG_EASY_LATEST"
    fi
else
    echo "‚úÖ WG-Easy √† jour : $WG_EASY_VERSION"
fi

##############################
#   LANCEMENT DU SCRIPT      #
##############################

# Lancement du menu principal uniquement si le script est ex√©cut√© directement
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    main_menu
fi
